# Практические задания по Vulkan API

В этом документе представлены практические задания для закрепления знаний, полученных при изучении Vulkan API. Задания расположены по возрастанию сложности и соответствуют этапам обучения из руководства.

## Этап 1: Инициализация Vulkan API

### Задание 1.1: Измените заголовок окна и его размеры
- Измените заголовок окна на "My Vulkan Renderer"
- Измените размеры окна на 1280x720
- Добавьте логирование нового размера и заголовка

### Задание 1.2: Включение/отключение валидационных слоев через конфигурацию
- Создайте конфигурационный файл (простой текстовый)
- Добавьте параметр для включения/отключения валидационных слоев
- Модифицируйте код для чтения этого параметра при запуске

### Задание 1.3: Расширение логирования
- Добавьте в VulkanLogger метод для вывода информации о драйвере и версии Vulkan
- Создайте функцию, которая выводит всю информацию о физическом устройстве в консоль или файл

## Этап 2: Устройства и очереди

### Задание 2.1: Рейтинг физических устройств
- Создайте систему оценки физических устройств с рейтингом
- Дискретные GPU должны получать более высокий рейтинг
- Устройства с поддержкой нужных расширений должны получать дополнительные баллы
- Выбирайте устройство с наивысшим рейтингом

### Задание 2.2: Реализация вычислительных очередей
- Добавьте поиск очередей вычислений (COMPUTE)
- Измените структуру QueueFamilyIndices, добавив поддержку вычислительных очередей
- Модифицируйте метод isDeviceSuitable для учета наличия вычислительных очередей

### Задание 2.3: Перечисление свойств отдельно для каждого устройства
- Измените метод printDeviceExtensionsInfo для вывода поддерживаемых расширений для всех устройств
- Добавьте вывод поддерживаемых функций устройства (VkPhysicalDeviceFeatures)

## Этап 3: Swap Chain

### Задание 3.1: Добавление поддержки HDR
- Модифицируйте выбор формата поверхности для поиска HDR-форматов (таких как R16G16B16A16_SFLOAT)
- Добавьте логику для приоритета HDR-форматов, если они доступны
- Если HDR недоступен, продолжайте использовать стандартный формат

### Задание 3.2: Пересоздание Swap Chain при изменении размера окна
- Добавьте обработку события изменения размера окна SDL
- Реализуйте метод для пересоздания Swap Chain с новыми размерами
- Убедитесь, что старая Swap Chain правильно очищается

### Задание 3.3: Переключение режима презентации
- Добавьте возможность динамического переключения между режимами презентации:
  - FIFO (вертикальная синхронизация)
  - MAILBOX (тройная буферизация)
  - IMMEDIATE (без синхронизации)
- Создайте простое меню или обработку клавиш для переключения режимов

## Этап 4: Графический конвейер и шейдеры

### Задание 4.1: Добавление параметра цвета
- Добавьте uniform-буфер для передачи параметра цвета в шейдер
- Создайте дескрипторный набор и layout для передачи uniform-буфера
- Модифицируйте шейдеры для использования этого параметра
- Реализуйте анимацию цвета фона через uniform-буфер

### Задание 4.2: Изменение примитивов
- Измените топологию примитивов с TRIANGLE_LIST на другую (LINE_STRIP, POINT_LIST)
- Добавьте возможность переключения между типами примитивов во время выполнения

### Задание 4.3: Динамические состояния
- Добавьте поддержку динамических состояний для viewport и scissor
- Реализуйте изменение viewport и scissor в каждом кадре без пересоздания графического конвейера

## Этап 5: Буферы и индексы

### Задание 5.1: Расширение геометрии
- Добавьте больше вершин для отрисовки квадрата или куба вместо треугольника
- Создайте индексный буфер для оптимизации использования вершин
- Используйте vkCmdDrawIndexed для рендеринга с использованием индексного буфера

### Задание 5.2: Обновление буферов
- Добавьте функциональность для динамического обновления буфера вершин
- Реализуйте анимацию вершин (вращение, пульсация и т.д.)
- Используйте отображение памяти (vkMapMemory) для эффективного обновления

### Задание 5.3: Оптимизация памяти
- Реализуйте объединение буферов вершин и индексов в один буфер памяти
- Используйте смещения для доступа к разным частям буфера
- Измерьте производительность до и после оптимизации

## Дополнительные задания

### Текстурирование
- Добавьте поддержку загрузки и использования текстур
- Модифицируйте вершины для добавления текстурных координат
- Обновите шейдеры для использования текстуры

### Multi-threading
- Реализуйте создание нескольких командных буферов в разных потоках
- Разделите рендеринг на несколько проходов, выполняемых параллельно

### Postprocessing
- Добавьте второй проход рендеринга для постобработки
- Реализуйте простой эффект (размытие, инверсия цвета и т.д.)
- Используйте framebuffer для хранения промежуточных результатов

---

Эти задания помогут закрепить знания Vulkan API на практике. Рекомендуется выполнять их последовательно, так как каждое следующее задание часто опирается на предыдущие. 